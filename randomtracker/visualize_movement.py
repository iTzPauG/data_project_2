#!/usr/bin/env python3
"""
Movement Visualizer
Reads movement data from CSV or JSON files and serves an interactive map via Flask web server.
"""

import json
import csv
import folium
from folium import plugins
import sys
import os
from flask import Flask, render_template, jsonify
import threading
import webbrowser
from datetime import datetime


def read_positions_from_csv(filename):
    """
    Read positions from a CSV file.
    
    Args:
        filename: Path to CSV file with format: tag_id,timestamp,latitude,longitude,node_id,street_name,road_type,poi_name,poi_type
        
    Returns:
        List of dictionaries with position data
    """
    positions = []
    
    with open(filename, 'r') as f:
        reader = csv.DictReader(f)
        for row in reader:
            # Skip empty rows or rows with missing data
            if not row or 'latitude' not in row or 'longitude' not in row:
                continue
            try:
                positions.append({
                    'tag_id': row.get('tag_id', '1'),
                    'timestamp': row.get('timestamp', ''),
                    'latitude': float(row['latitude']),
                    'longitude': float(row['longitude']),
                    'node_id': row.get('node_id', ''),
                    'street_name': row.get('street_name', ''),
                    'road_type': row.get('road_type', ''),
                    'poi_name': row.get('poi_name', ''),
                    'poi_type': row.get('poi_type', '')
                })
            except (ValueError, KeyError) as e:
                # Skip malformed rows
                continue
    
    return positions


def read_positions_from_json(filename):
    """
    Read positions from a JSON file.
    
    Args:
        filename: Path to JSON file generated by random_movement.py
        
    Returns:
        List of dictionaries with position data
    """
    with open(filename, 'r') as f:
        data = json.load(f)
    
    # Handle the format from generate_timed_movement
    if 'movements' in data:
        return data['movements']
    
    # Handle other possible formats
    return data


def create_movement_map(positions, output_file='movement_map.html'):
    """
    Create an interactive map showing the movement track.
    
    Args:
        positions: List of position dictionaries with latitude and longitude
        output_file: Name of the HTML file to generate
    """
    if not positions:
        print("Error: No positions to display")
        return
    
    # Calculate center point (average of all positions)
    avg_lat = sum(p['latitude'] for p in positions) / len(positions)
    avg_lon = sum(p['longitude'] for p in positions) / len(positions)
    
    # Create map centered on the average position
    m = folium.Map(
        location=[avg_lat, avg_lon],
        zoom_start=15,
        tiles='OpenStreetMap'
    )
    
    # Prepare coordinates for the path
    coordinates = [[p['latitude'], p['longitude']] for p in positions]
    
    # Add the movement path as a colored line
    folium.PolyLine(
        coordinates,
        color='blue',
        weight=3,
        opacity=0.7,
        popup='Movement Track'
    ).add_to(m)
    
    # Add markers for start and end points
    # Start point (green)
    folium.Marker(
        location=[positions[0]['latitude'], positions[0]['longitude']],
        popup=f"Start<br>{positions[0].get('timestamp', 'N/A')}",
        icon=folium.Icon(color='green', icon='play', prefix='fa')
    ).add_to(m)
    
    # End point (red)
    folium.Marker(
        location=[positions[-1]['latitude'], positions[-1]['longitude']],
        popup=f"End<br>{positions[-1].get('timestamp', 'N/A')}",
        icon=folium.Icon(color='red', icon='stop', prefix='fa')
    ).add_to(m)
    
    # Add numbered markers for intermediate waypoints (every 10th point if many points)
    step = max(1, len(positions) // 10)
    for i in range(1, len(positions) - 1, step):
        folium.CircleMarker(
            location=[positions[i]['latitude'], positions[i]['longitude']],
            radius=4,
            popup=f"Point {i}<br>{positions[i].get('timestamp', 'N/A')}",
            color='darkblue',
            fill=True,
            fillColor='lightblue',
            fillOpacity=0.7
        ).add_to(m)
    
    # Add measurement tool
    plugins.MeasureControl(
        position='topleft',
        primary_length_unit='meters',
        secondary_length_unit='kilometers',
        primary_area_unit='sqmeters',
        secondary_area_unit='acres'
    ).add_to(m)
    
    # Add fullscreen option
    plugins.Fullscreen(
        position='topleft',
        title='Full Screen',
        title_cancel='Exit Full Screen',
        force_separate_button=True
    ).add_to(m)
    
    # Add layer control
    folium.LayerControl().add_to(m)
    
    # Save the map
    m.save(output_file)
    print(f"‚úì Map saved to {output_file}")
    print(f"  Total points: {len(positions)}")
    print(f"  Start: ({positions[0]['latitude']:.6f}, {positions[0]['longitude']:.6f})")
    print(f"  End: ({positions[-1]['latitude']:.6f}, {positions[-1]['longitude']:.6f})")


def create_animated_map(positions, output_file='animated_map.html'):
    """
    Create an animated map showing the movement over time.
    
    Args:
        positions: List of position dictionaries with latitude, longitude, and timestamp
        output_file: Name of the HTML file to generate
    """
    if not positions:
        print("Error: No positions to display")
        return
    
    # Calculate center point
    avg_lat = sum(p['latitude'] for p in positions) / len(positions)
    avg_lon = sum(p['longitude'] for p in positions) / len(positions)
    
    # Create map
    m = folium.Map(
        location=[avg_lat, avg_lon],
        zoom_start=15,
        tiles='OpenStreetMap'
    )
    
    # Prepare data for animation
    features = []
    for i, pos in enumerate(positions):
        feature = {
            'type': 'Feature',
            'geometry': {
                'type': 'Point',
                'coordinates': [pos['longitude'], pos['latitude']]
            },
            'properties': {
                'time': pos.get('timestamp', f'Point {i}'),
                'popup': f"Point {i}",
                'icon': 'circle',
                'iconstyle': {
                    'fillColor': 'blue',
                    'fillOpacity': 0.8,
                    'stroke': 'true',
                    'radius': 5
                }
            }
        }
        features.append(feature)
    
    # Add animated markers
    plugins.TimestampedGeoJson(
        {
            'type': 'FeatureCollection',
            'features': features
        },
        period='PT1S',
        add_last_point=True,
        auto_play=False,
        loop=False,
        max_speed=10,
        loop_button=True,
        date_options='YYYY-MM-DD HH:mm:ss',
        time_slider_drag_update=True
    ).add_to(m)
    
    # Add the full path as a reference
    coordinates = [[p['latitude'], p['longitude']] for p in positions]
    folium.PolyLine(
        coordinates,
        color='lightblue',
        weight=2,
        opacity=0.4,
        popup='Full Track'
    ).add_to(m)
    
    # Save the map
    m.save(output_file)
    print(f"‚úì Animated map saved to {output_file}")


def create_map_html(positions):
    """
    Create an interactive map and return as HTML string.
    
    Args:
        positions: List of position dictionaries with latitude and longitude
        
    Returns:
        HTML string of the map
    """
    if not positions:
        return "<html><body><h1>No positions to display</h1></body></html>"
    
    # Group positions by tag_id
    tags = {}
    for pos in positions:
        tag_id = pos.get('tag_id', '1')
        if tag_id not in tags:
            tags[tag_id] = []
        tags[tag_id].append(pos)
    
    # Calculate center point from all positions
    avg_lat = sum(p['latitude'] for p in positions) / len(positions)
    avg_lon = sum(p['longitude'] for p in positions) / len(positions)
    
    # Create map
    m = folium.Map(
        location=[avg_lat, avg_lon],
        zoom_start=15,
        tiles='OpenStreetMap'
    )
    
    # Color palette for different tags
    colors = ['blue', 'red', 'green', 'purple', 'orange', 'darkred', 
              'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 
              'darkpurple', 'pink', 'lightblue', 'lightgreen', 'gray', 
              'black', 'lightgray']
    
    # Draw path for each tag
    for idx, (tag_id, tag_positions) in enumerate(tags.items()):
        color = colors[idx % len(colors)]
        coordinates = [[p['latitude'], p['longitude']] for p in tag_positions]
        
        # Add the movement path
        folium.PolyLine(
            coordinates,
            color=color,
            weight=3,
            opacity=0.7,
            popup=f'Tag {tag_id} Track'
        ).add_to(m)
        
        # Start point
        start_popup = f"Tag {tag_id} Start<br>{tag_positions[0].get('timestamp', 'N/A')}<br>{tag_positions[0].get('street_name', 'Unknown')}<br>Type: {tag_positions[0].get('road_type', 'N/A')}"
        poi_name = tag_positions[0].get('poi_name', '')
        poi_type = tag_positions[0].get('poi_type', '')
        if poi_name or poi_type:
            start_popup += f"<br>Near: {poi_name if poi_name else poi_type}"
        folium.Marker(
            location=[tag_positions[0]['latitude'], tag_positions[0]['longitude']],
            popup=start_popup,
            icon=folium.Icon(color=color if color in ['red', 'blue', 'green', 'purple', 'orange', 'darkred', 'lightred', 'beige', 'darkblue', 'darkgreen', 'cadetblue', 'darkpurple', 'pink', 'lightblue', 'lightgreen', 'gray', 'black', 'lightgray'] else 'blue', 
                           icon='play', prefix='fa')
        ).add_to(m)
        
        # End point (current position)
        current_popup = f"Tag {tag_id} Current<br>{tag_positions[-1].get('timestamp', 'N/A')}<br>{tag_positions[-1].get('street_name', 'Unknown')}<br>Type: {tag_positions[-1].get('road_type', 'N/A')}"
        poi_name = tag_positions[-1].get('poi_name', '')
        poi_type = tag_positions[-1].get('poi_type', '')
        if poi_name or poi_type:
            current_popup += f"<br>Near: {poi_name if poi_name else poi_type}"
        folium.CircleMarker(
            location=[tag_positions[-1]['latitude'], tag_positions[-1]['longitude']],
            radius=8,
            popup=current_popup,
            color=color,
            fill=True,
            fillColor=color,
            fillOpacity=0.9
        ).add_to(m)
    
    # Add measurement tool
    plugins.MeasureControl(
        position='topleft',
        primary_length_unit='meters',
        secondary_length_unit='kilometers'
    ).add_to(m)
    
    # Add fullscreen option
    plugins.Fullscreen(
        position='topleft',
        title='Full Screen',
        title_cancel='Exit Full Screen',
        force_separate_button=True
    ).add_to(m)
    
    # Add legend
    legend_html = f'''
    <div style="position: fixed; 
                bottom: 50px; right: 50px; width: 200px; height: auto; 
                background-color: white; border:2px solid grey; z-index:9999; 
                font-size:14px; padding: 10px">
    <p style="margin:0; font-weight: bold;">Active Tags: {len(tags)}</p>
    <hr style="margin: 5px 0;">
    '''
    for idx, tag_id in enumerate(tags.keys()):
        color = colors[idx % len(colors)]
        legend_html += f'<p style="margin:2px 0;"><span style="color:{color};">‚óè</span> Tag {tag_id}</p>'
    legend_html += '</div>'
    
    m.get_root().html.add_child(folium.Element(legend_html))
    
    # Return HTML
    return m._repr_html_()


# Flask app
app = Flask(__name__)
DATA_FILE = 'live_tracking.csv'
PORT = 4444


@app.route('/')
def index():
    """Main page with live updating map."""
    return render_template('index.html')


@app.route('/map')
def map_view():
    """Return the map HTML."""
    try:
        if os.path.exists(DATA_FILE):
            positions = read_positions_from_csv(DATA_FILE)
            if not positions:
                return "<html><body><h1>Waiting for tracking data...</h1><p>No positions recorded yet. Please wait...</p></body></html>"
            return create_map_html(positions)
        else:
            return "<html><body><h1>Waiting for tracking data...</h1><p>Start the random_movement.py script to begin tracking.</p></body></html>"
    except Exception as e:
        return f"<html><body><h1>Error loading map</h1><p>{str(e)}</p><p>Please check the CSV file format.</p></body></html>"


@app.route('/info')
def info():
    """Return tracking info as JSON."""
    try:
        if os.path.exists(DATA_FILE):
            positions = read_positions_from_csv(DATA_FILE)
            last_timestamp = positions[-1].get('timestamp', 'N/A') if positions else 'N/A'
            
            # Format timestamp if available
            if last_timestamp != 'N/A':
                try:
                    dt = datetime.fromisoformat(last_timestamp)
                    last_timestamp = dt.strftime('%Y-%m-%d %H:%M:%S')
                except:
                    pass
            
            return jsonify({
                'point_count': len(positions),
                'last_update': last_timestamp,
                'file': DATA_FILE
            })
        else:
            return jsonify({
                'point_count': 0,
                'last_update': 'Waiting for data...',
                'file': DATA_FILE
            })
    except Exception as e:
        return jsonify({
            'point_count': 0,
            'last_update': f'Error: {str(e)}',
            'file': DATA_FILE
        })


def open_browser():
    """Open browser after a short delay."""
    import time
    time.sleep(1.5)
    webbrowser.open(f'http://localhost:{PORT}')


def serve_map(data_file='live_tracking.csv', auto_open=True):
    """
    Start Flask server to serve live map.
    
    Args:
        data_file: Path to the CSV data file
        auto_open: Whether to automatically open browser
    """
    global DATA_FILE
    DATA_FILE = data_file
    
    print("=" * 60)
    print("üåê Starting Live Movement Tracker Web Server")
    print("=" * 60)
    print(f"üìä Data file: {data_file}")
    print(f"üåç Server URL: http://localhost:{PORT}")
    print(f"üîÑ Map auto-refreshes every 5 seconds")
    print("\n‚ö†Ô∏è  Press Ctrl+C to stop the server")
    print("=" * 60)
    
    if auto_open:
        threading.Thread(target=open_browser, daemon=True).start()
    
    app.run(host='0.0.0.0', port=PORT, debug=False)


def main():
    """Main function to visualize movement data."""
    
    # Check for command line arguments
    if len(sys.argv) > 1:
        if sys.argv[1] == '--serve' or sys.argv[1] == '-s':
            # Serve mode
            data_file = sys.argv[2] if len(sys.argv) > 2 else 'live_tracking.csv'
            if len(sys.argv) > 3:
                global PORT
                PORT = int(sys.argv[3])
            serve_map(data_file)
            return
        else:
            input_file = sys.argv[1]
    else:
        # Default: serve live tracking
        if os.path.exists('live_tracking.csv'):
            print("Starting web server for live tracking...")
            serve_map('live_tracking.csv')
            return
        elif os.path.exists('positions.csv'):
            input_file = 'positions.csv'
        elif os.path.exists('movement_data.json'):
            input_file = 'movement_data.json'
        else:
            print("Error: No input file found.")
            print("\nUsage:")
            print("  python visualize_movement.py                    # Serve live_tracking.csv on localhost:4444")
            print("  python visualize_movement.py --serve [file]     # Serve specified file on localhost")
            print("  python visualize_movement.py [file]             # Generate static HTML files")
            sys.exit(1)
    
    print(f"Reading data from {input_file}...")
    
    # Read positions based on file type
    if input_file.endswith('.csv'):
        positions = read_positions_from_csv(input_file)
    elif input_file.endswith('.json'):
        positions = read_positions_from_json(input_file)
    else:
        print(f"Error: Unsupported file format. Use .csv or .json")
        sys.exit(1)
    
    print(f"Loaded {len(positions)} positions")
    
    # Create static map
    print("\nCreating static movement map...")
    create_movement_map(positions, 'movement_map.html')
    
    # Create animated map if timestamps are available
    if positions and positions[0].get('timestamp'):
        print("\nCreating animated map...")
        create_animated_map(positions, 'animated_map.html')
    
    print("\n" + "=" * 60)
    print("Visualization complete!")
    print("Open the following files in your browser:")
    print("  - movement_map.html (static map with full track)")
    if positions and positions[0].get('timestamp'):
        print("  - animated_map.html (animated playback)")
    print("\nTip: Use 'python visualize_movement.py --serve' for live updates!")
    print("=" * 60)


if __name__ == "__main__":
    main()
